@page "/weather"
@using VideoManager.Models
@using System.ComponentModel.DataAnnotations
@using System.IO.Compression
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using CsvHelper
@using System.Globalization
@inject ProtectedSessionStorage ProtectedSessionStore
@inject IRealmService RealmService
@inject IPizzaService PizzaService
@inject IPizzaTagService PizzaTagService
@inject ITagService TagService
@inject HttpClient Http
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery
@inject IHttpClientFactory ClientFactory
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>Weather</PageTitle>

<h1>Weather</h1>

<section>

    <div style="display: flex;">
        <div style="flex: 1; background: lightblue; padding: 10px;">
            <p> Block 1: Realm Editor </p>

            <InputFile OnChange="HandleInputConsumeClick" />

            <Button Color="ButtonColor.Warning"
                    Disabled="@(string.IsNullOrEmpty(selectedRealmFileName) || (selectedRealmFile == null))"
                    @ref=importRealmButton
                    @onclick="HandleButtonImportRealmClick">
                Import Realm
            </Button>

            <EditForm EditContext="@editContext">

                <DataAnnotationsValidator />
                <ValidationSummary />

                <div class="mb-3">
                    <label class="form-label">Realm Name:</label>
                    <InputText @bind-Value="currentRealm.name" Placeholder="Enter name" />
                </div>

                <div class="mb-3">
                    <label class="form-label">Realm View:</label>
                    <InputText @bind-Value="currentRealm.view" Placeholder="Enter view" />
                </div>

                <div class="mb-3">
                    <label class="form-label">Realm Action:</label>
                    <InputSelect @bind-Value="currentRealm.DefaultAction">
                        @foreach (ExplorerDefaultAction action in Enum.GetValues(typeof(ExplorerDefaultAction)))
                        {
                            <option value="@action">@action</option>
                        }
                    </InputSelect>
                </div>

                @if (currentRealm.DefaultAction == ExplorerDefaultAction.OpenLink)
                {

                    <div class="mb-3">
                        <label class="form-label">Realm App:</label>
                        <InputText @bind-Value="currentRealm.PreferredApp"
                                   placeholder="com.myapp.handler" />
                    </div>

                }

                <Button Color="ButtonColor.Primary"
                        Disabled="@(!formIsValid)"
                        @ref=addButton
                        @onclick="HandleButtonAddTagClick">
                    Add / Update
                </Button>

                <Button Color="ButtonColor.Success"
                        Disabled="@(!formIsValid)"
                        @ref=exportButton
                        @onclick="HandleButtonExportRealmClick">
                    Export Realm
                </Button>

                <Button Color="ButtonColor.Danger"
                        Disabled="@(!formIsValid)"
                        @ref=deleteButton
                        @onclick="HandleButtonDeleteTagClick">
                    Delete Record
                </Button>

            </EditForm>
        </div>
        <div style="flex: 1; background: lightgreen; padding: 10px;">
            <p> Block 1a: All Realms </p>

            <InputFile OnChange="HandleInputConsumeClick" />
            <Button Color="ButtonColor.Warning"
                    Disabled="@(string.IsNullOrEmpty(selectedRealmFileName) || (selectedRealmFile == null))"
                    @ref=importAllButton
                    @onclick="HandleButtonImportAllClick">
                Import All
            </Button>
            <Button Color="ButtonColor.Success"
                    @ref="exportAllButton"
                    @onclick="HandleButtonExportAllClick">
                Export All
            </Button>

        </div>
    </div>

</section>

<section>

    <p> Block 2: Realm Choice </p>

    @if (allRealms == null)
    {
        <p role="status">No realms found...</p>
    }
    else
    {

        <Grid TItem="Realm"
              AllowRowClick="true"
              AllowSorting="true"
              Class="table table-hover"
              Data="allRealms"
              HeaderRowCssClass="bg-primary text-white border-bottom-0"
              OnRowClick="OnRowClick"
              Responsive="true">

            <GridColumns>
                <GridColumn TItem="Realm" HeaderText="Name">
                    @context.name
                </GridColumn>

                <GridColumn TItem="Realm" HeaderText="View">
                    @context.view
                </GridColumn>
            </GridColumns>

        </Grid>
    }

</section>

@code {

    private Realm currentRealm = new Realm();
    private List<Realm> allRealms = default!;

    private string? selectedRealmFileName;
    private IBrowserFile? selectedRealmFile;
    private MemoryStream? selectedRealmZip;

    private EditContext editContext = default!;

    private Button importRealmButton = default!;
    private Button addButton = default!;
    private Button exportButton = default!;
    private Button deleteButton = default!;
    private Button importAllButton = default!;
    private Button exportAllButton = default!;

    private Button consumeButton = default!;
    private Button pumpButton = default!;
    private Button dumpButton = default!;

    private bool formIsValid = false;

    private bool isConnected;

    protected override void OnInitialized()
    {
        editContext = new EditContext(currentRealm);
        editContext.OnValidationStateChanged += HandleValidationChanged;
        base.OnInitialized();
    }

    protected override async Task OnInitializedAsync()
    {
        currentRealm.name = "";
        allRealms = await RealmService.GetRealmList();
        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            isConnected = true;
            StateHasChanged();
        }
    }

    private async Task OnRowClick(GridRowEventArgs<Realm> args)
    {
        var r = args.Item;

        currentRealm.name = r.name;
        currentRealm.view = r.view;
        currentRealm.DefaultAction = r.DefaultAction;
        currentRealm.PreferredApp = r.PreferredApp;

        editContext.Validate();
    }

    private async Task HandleButtonImportRealmClick()
    {

        if (selectedRealmZip is null)
            return;

        selectedRealmZip.Position = 0;

        using var archive = new ZipArchive(selectedRealmZip, ZipArchiveMode.Read);

        IEnumerable<ShortTag>? tagRecords = null;
        IEnumerable<Realm>? realmRecords = null;
        IEnumerable<EmptyPizza>? pizzaRecords = null;
        IEnumerable<PizzaTag>? pizzaTagRecords = null;

        foreach (var entry in archive.Entries)
        {
            // entry.FullName  -> path inside zip
            // entry.Name      -> file name only

            switch (entry.FullName)
            {
                case "tags.csv":

                    {

                        using var entryStream = entry.Open();
                        using var reader = new StreamReader(entryStream);
                        using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

                        tagRecords = csv.GetRecords<ShortTag>().ToList();

                        break;

                    }

                case "realms.csv":

                    {

                        using var entryStream = entry.Open();
                        using var reader = new StreamReader(entryStream);
                        using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

                        realmRecords = csv.GetRecords<Realm>().ToList();

                        break;

                    }

                default:
                    {
                        bool subfolderCheck =
                            entry.FullName.StartsWith(currentRealm.name + "/thmb/") ||
                            entry.FullName.StartsWith(currentRealm.name + "/cntn/");
                        if (subfolderCheck && (!string.IsNullOrEmpty(entry.Name)))
                        {
                            var destinationPath = Path.Combine(currentRealm.view,
                                                               entry.FullName.Replace('/', Path.DirectorySeparatorChar));

                            Directory.CreateDirectory(Path.GetDirectoryName(destinationPath)!);

                            using var entryStream = entry.Open();
                            using var fileStream = File.Create(destinationPath);
                            await entryStream.CopyToAsync(fileStream);
                        }
                        else if (entry.FullName.StartsWith(currentRealm.name) && (entry.Name) == "tab.csv")
                        {

                            using var entryStream = entry.Open();
                            using var reader = new StreamReader(entryStream);
                            using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

                            pizzaRecords = csv.GetRecords<EmptyPizza>().ToList();

                            break;

                        }
                        else if (entry.FullName.StartsWith(currentRealm.name) && (entry.Name) == "tag.csv")
                        {

                            using var entryStream = entry.Open();
                            using var reader = new StreamReader(entryStream);
                            using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

                            pizzaTagRecords = csv.GetRecords<PizzaTag>().ToList();

                            break;

                        }

                        break;
                    }
            }
        }

        if (tagRecords != null)
        {
            foreach (var record in tagRecords)
            {
                await TagService.CreateTag(record);
            }
        }

        if (realmRecords != null)
        {
            foreach (var record in realmRecords)
            {
                await RealmService.AddOrUpdateRealm(record);
            }
        }

        if (pizzaRecords != null)
        {
            foreach (var record in pizzaRecords)
            {
                await PizzaService.CreatePizza(record);
            }
        }

        if (pizzaTagRecords != null)
        {
            foreach (var record in pizzaTagRecords)
            {
                await PizzaTagService.CreateTag(record);
            }
        }
    }

    private async Task HandleButtonAddTagClick()
    {
        addButton.ShowLoading("Adding...");

        // await Task.Delay(1000);
        Realm addOrUpdateRealm = new Realm
            {
                name = currentRealm.name,
                view = currentRealm.view,
                DefaultAction = currentRealm.DefaultAction,
                PreferredApp = currentRealm.PreferredApp
            };
        await RealmService.AddOrUpdateRealm(addOrUpdateRealm);

        allRealms = await RealmService.GetRealmList();

        addButton.HideLoading();
    }

    private async Task HandleButtonExportRealmClick()
    {
        var realm = currentRealm.name;
        var view = currentRealm.view;

        await JSRuntime.InvokeVoidAsync(
            "open",
            $"/api/export_single?realm={Uri.EscapeDataString(realm)}&view={Uri.EscapeDataString(view)}",
            "_blank");
    }

    private async Task HandleButtonDeleteTagClick()
    {
        deleteButton.ShowLoading("Deleting...");

        // await Task.Delay(1000);
        await RealmService.DeleteRealm(currentRealm.name);

        allRealms = await RealmService.GetRealmList();

        deleteButton.HideLoading();
    }

    private async Task HandleInputConsumeClick(InputFileChangeEventArgs e)
    {

        selectedRealmFile = e.File;
        selectedRealmFileName = selectedRealmFile.Name;

        selectedRealmZip = new MemoryStream();

        await using var uploadStream =
            selectedRealmFile.OpenReadStream(maxAllowedSize: 50 * 1024 * 1024);

        await uploadStream.CopyToAsync(selectedRealmZip);
        selectedRealmZip.Position = 0;

        /*

        using var reader = new StreamReader(file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024));
        var content = await reader.ReadToEndAsync();

        var tokenResponse = await Http.GetFromJsonAsync<AntiforgeryTokenDto>("/api/antiforgery/token");
        var token = tokenResponse?.Token;

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, "/api/processfile");
        requestMessage.Headers.Add("X-XSRF-TOKEN", token!);
        requestMessage.Content = JsonContent.Create(new { FileContent = content });

        var response = await Http.SendAsync(requestMessage);
        var result = await response.Content.ReadFromJsonAsync<ResultDto>();

        Console.WriteLine($"Python result: {result?.Result}");

        */
    }

    private void HandleValidationChanged(object? sender, ValidationStateChangedEventArgs e)
    {
        formIsValid = !editContext.GetValidationMessages().Any();
        StateHasChanged();
    }

    public class ResultDto
    {
        public string Result { get; set; } = string.Empty;
    }

    private async Task HandleButtonImportAllClick()
    {

        importAllButton.ShowLoading("Importing...");

        if (selectedRealmZip is null)
            return;

        selectedRealmZip.Position = 0;

        using var archive = new ZipArchive(selectedRealmZip, ZipArchiveMode.Read);

        IEnumerable<ShortTag>? tagRecords = null;
        IEnumerable<Realm>? realmRecords = null;
        IEnumerable<EmptyPizza>? pizzaRecords = null;
        IEnumerable<PizzaTag>? pizzaTagRecords = null;

        foreach (var entry in archive.Entries)
        {
            // entry.FullName  -> path inside zip
            // entry.Name      -> file name only

            switch (entry.FullName)
            {
                case "tags.csv":

                    {

                        using var entryStream = entry.Open();
                        using var reader = new StreamReader(entryStream);
                        using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

                        tagRecords = csv.GetRecords<ShortTag>().ToList();

                        break;

                    }

                case "realms.csv":

                    {

                        using var entryStream = entry.Open();
                        using var reader = new StreamReader(entryStream);
                        using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

                        realmRecords = csv.GetRecords<Realm>().ToList();

                        break;

                    }

                default:
                    break;
            }
        }

        if (tagRecords != null)
        {
            foreach (var record in tagRecords)
            {
                await TagService.CreateTag(record);
            }
        }

        if (realmRecords != null)
        {
            foreach (var record in realmRecords)
            {
                await RealmService.AddOrUpdateRealm(record);
            }
        }

        List<string> realmNames = realmRecords?
            .Select(r => r.name)
            .ToList()
            ?? new List<string>();

        foreach (var entry in archive.Entries)
        {
            // entry.FullName  -> path inside zip
            // entry.Name      -> file name only

            var matchedFoldersRealm = realmNames.FirstOrDefault(r =>
                entry.FullName.StartsWith(r + "/thmb/") ||
                entry.FullName.StartsWith(r + "/cntn/"));
            var matchedFilesRealm = realmNames.FirstOrDefault(r =>
                entry.FullName.StartsWith(r + "/tab.csv") ||
                entry.FullName.StartsWith(r + "/tag.csv"));
            var matchedRealmObj = realmRecords.FirstOrDefault(r => r.name == matchedFoldersRealm);
            if (((matchedFoldersRealm == null) || (matchedRealmObj == null)) && (matchedFilesRealm == null))
                continue;

            if ((matchedFoldersRealm != null) && (!string.IsNullOrEmpty(entry.Name)))
            {
                string targetDir = Path.GetDirectoryName(matchedRealmObj.view);

                var destinationPath = Path.Combine(targetDir,
                                                    entry.FullName.Replace('/', Path.DirectorySeparatorChar));

                Directory.CreateDirectory(Path.GetDirectoryName(destinationPath)!);

                using var entryStream = entry.Open();
                using var fileStream = File.Create(destinationPath);
                await entryStream.CopyToAsync(fileStream);
                continue;
            }
            else if (entry.FullName.StartsWith(matchedFilesRealm) && (entry.Name) == "tab.csv")
            {

                using var entryStream = entry.Open();
                using var reader = new StreamReader(entryStream);
                using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

                pizzaRecords = csv.GetRecords<EmptyPizza>().ToList();


                if (pizzaRecords != null)
                {
                    foreach (var record in pizzaRecords)
                    {
                        await PizzaService.CreatePizza(record);
                    }
                }
                 continue;

            }
            else if (entry.FullName.StartsWith(matchedFilesRealm) && (entry.Name) == "tag.csv")
            {

                using var entryStream = entry.Open();
                using var reader = new StreamReader(entryStream);
                using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);

                pizzaTagRecords = csv.GetRecords<PizzaTag>().ToList();

                if (pizzaTagRecords != null)
                {
                    foreach (var record in pizzaTagRecords)
                    {
                        await PizzaTagService.CreateTag(record);
                    }
                }
                continue;

            }

        }

        importAllButton.HideLoading();

    }

    private async Task HandleButtonExportAllClick()
    {

        await JSRuntime.InvokeVoidAsync(
            "open",
            $"/api/export_all",
            "_blank");
    }

}
